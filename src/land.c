/*
 * See Licensing and Copyright notice in naev.h
 */

/**
 * @file land.c
 *
 * @brief Handles all the landing menus and actions.
 */


/** @cond */
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "physfs.h"

#include "naev.h"
/** @endcond */

#include "land.h"

#include "array.h"
#include "camera.h"
#include "conf.h"
#include "credits.h"
#include "dialogue.h"
#include "economy.h"
#include "equipment.h"
#include "escort.h"
#include "event.h"
#include "gui.h"
#include "hook.h"
#include "info.h"
#include "land_outfits.h"
#include "land_shipyard.h"
#include "land_trade.h"
#include "log.h"
#include "map.h"
#include "menu.h"
#include "mission.h"
#include "music.h"
#include "ndata.h"
#include "news.h"
#include "nlua.h"
#include "nlua_tk.h"
#include "nluadef.h"
#include "npc.h"
#include "nstring.h"
#include "ntime.h"
#include "player.h"
#include "rng.h"
#include "save.h"
#include "shiplog.h"
#include "toolkit.h"


/*
 * we use visited flags to not duplicate missions generated
 */
#define VISITED_LAND          (1<<0) /**< Player already landed. */
#define VISITED_COMMODITY     (1<<1) /**< Player already visited commodities. */
#define VISITED_BAR           (1<<2) /**< Player already visited bar. */
#define VISITED_OUTFITS       (1<<3) /**< Player already visited outfits. */
#define VISITED_SHIPYARD      (1<<4) /**< Player already visited shipyard. */
#define VISITED_EQUIPMENT     (1<<5) /**< Player already visited equipment. */
#define VISITED_MISSION       (1<<6) /**< Player already visited mission computer. */
#define visited(f)            (land_visited |= (f)) /**< Mark place is visited. */
#define has_visited(f)        (land_visited & (f)) /**< Check if player has visited. */
static unsigned int land_visited = 0; /**< Contains what the player visited. */

/* Which tabs have been generated by their respective open functions. */
unsigned int land_generated = 0;

/*
 * land variables
 */
int landed = 0; /**< Is player landed. */
int land_loaded = 0; /**< Finished loading? */
int land_takeoff = 0; /**< Script forces takeoff. */
unsigned int land_wid = 0; /**< Land window ID, also used in gui.c */
static int land_regen = 0; /**< Whether or not regenning. */
static int land_windowsMap[LAND_NUMWINDOWS]; /**< Mapping of windows. */
static unsigned int *land_windows = NULL; /**< Landed window ids. */
Planet* land_planet = NULL; /**< Planet player landed at. */
static glTexture *gfx_exterior = NULL; /**< Exterior graphic of the landed planet. */
static int map_clicked = 0; /**< Whether the map was just clicked. */
static int updating_tabs = 0; /**< Whether land_updateTabs() is running. */

/*
 * mission computer stack
 */
static Mission* mission_computer = NULL; /**< Missions at the computer. */
static int mission_ncomputer = 0; /**< Number of missions at the computer. */
static int mission_map_minimal = 1; /**< Stored minimal mode setting. */

/*
 * Bar stuff.
 */
static glTexture *mission_portrait = NULL; /**< Mission portrait. */

/*
 * player stuff
 */
static int last_window = 0; /**< Default window. */


/*
 * Error handling.
 */
static char errorlist[STRMAX_SHORT];
static char errorreason[STRMAX_SHORT];
static int errorappend;
static char *errorlist_ptr;


/*
 * Rescue.
 */
static nlua_env rescue_env = LUA_NOREF; /**< Rescue Lua env. */
static void land_stranded (void);


/*
 * prototypes
 */
static void land_createMainTab( unsigned int wid );
static void land_cleanupWindow( unsigned int wid, char *name );
static void land_changeTab( unsigned int wid, char *wgt, int old, int tab );
static void land_updateMainTab(void);
/* spaceport */
static void spaceport_saveSnapshot(unsigned int wid, char *str);
/* spaceport bar */
static void bar_getDim( int wid,
      int *w, int *h, int *iw, int *ih, int *bw, int *bh );
static void bar_open( unsigned int wid );
static int bar_genList( unsigned int wid );
static void bar_update( unsigned int wid, char* str );
static void bar_close( unsigned int wid, char* str );
static void bar_approach( unsigned int wid, char* str );
static int news_load (void);
/* mission computer */
static void misn_getSize(wid_t wid, int *w, int *h, int *dw, int *dh, int *lh,
      int *mw, int *bw);
static void misn_open( unsigned int wid );
static void misn_close( unsigned int wid, char *name );
static void misn_accept( unsigned int wid, char* str );
static void misn_currentList(unsigned int wid, char* str);
static void misn_genList( unsigned int wid, int first );
static void misn_chkMinimal(unsigned int wid, char* str);
static void misn_update( unsigned int wid, char* str );


/**
 * @brief Queue a takeoff.
 */
void land_queueTakeoff (void)
{
   land_takeoff = 1;
}


/**
 * @brief Check to see if finished loading.
 */
int land_doneLoading (void)
{
   if (landed && land_loaded)
      return 1;
   return 0;
}


/**
 * @brief Makes sure it's valid to change ships in the equipment view.
 *    @param shipname Ship being changed to.
 */
int can_swapEquipment( const char *shipname )
{
   int failure = 0;
   Pilot *newship;
   newship = player_getShip(shipname);
   int diff;

   if (strcmp(shipname,player.p->name)==0) { /* Already onboard. */
      land_errDialogueBuild( _("You're already onboard the %s."), shipname );
      failure = 1;
   }
   if (pilot_cargoUsed(player.p) > (pilot_cargoFree(newship) + pilot_cargoUsed(newship))) { /* Current ship has too much cargo. */
      diff = pilot_cargoUsed(player.p) - pilot_cargoFree(newship);
      land_errDialogueBuild( n_(
               "You have %d tonne more cargo than the new ship can hold.",
               "You have %d tonnes more cargo than the new ship can hold.",
               diff),
            diff );
      failure = 1;
   }
   return !failure;
}


/**
 * @brief Generates error dialogues used by several landing tabs.
 *    @param name Name of the ship, outfit or commodity being acted upon.
 *    @param type Type of action.
 */
int land_errDialogue( const char *name, char *type )
{
   errorlist_ptr = NULL;
   if (strcmp(type,"tradeShip")==0)
      shipyard_canTrade( name );
   else if (strcmp(type,"buyShip")==0)
      shipyard_canBuy( name, land_planet );
   else if (strcmp(type,"swapEquipment")==0)
      can_swapEquipment( name );
   else if (strcmp(type,"swap")==0)
      can_swap( name );
   else if (strcmp(type,"sellShip")==0)
      can_sell( name );
   else if (strcmp(type,"buyOutfit")==0)
      outfit_canBuy( name, land_planet );
   else if (strcmp(type,"sellOutfit")==0)
      outfit_canSell( name );
   else if (strcmp(type,"buyCommodity")==0)
      commodity_canBuy( commodity_get( name ) );
   else if (strcmp(type,"sellCommodity")==0)
      commodity_canSell( commodity_get( name ) );
   if (errorlist_ptr != NULL) {
      dialogue_alert( "%s", errorlist );
      return 1;
   }
   return 0;
}

/**
 * @brief Generates error dialogues used by several landing tabs.
 *    @param fmt String with printf-like formatting
 */
void land_errDialogueBuild( const char *fmt, ... )
{
   va_list ap;

   if (fmt == NULL)
      return;
   else { /* get the message */
      va_start(ap, fmt);
      vsnprintf(errorreason, sizeof(errorreason), fmt, ap);
      va_end(ap);
   }

   if (errorlist_ptr == NULL) /* Initialize on first run. */
      errorappend = scnprintf( errorlist, sizeof(errorlist), "%s", errorreason );
   else /* Append newest error to the existing list. */
      scnprintf( &errorlist[errorappend],  sizeof(errorlist)-errorappend, "\n%s", errorreason );
   errorlist_ptr = errorlist;
}


/**
 * @brief Gets the dimensions of the spaceport bar window.
 */
static void bar_getDim( int wid,
      int *w, int *h, int *iw, int *ih, int *bw, int *bh )
{
   /* Get window dimensions. */
   window_dimWindow( wid, w, h );

   /* Calculate dimensions of portraits. */
   *iw = 704 + (*w - LAND_WIDTH);
   *ih = *h - 60;

   /* Calculate button dimensions. */
   *bw = (*w - *iw - 20 - 3*10)/2;
   *bh = LAND_BUTTON_HEIGHT;
}
/**
 * @brief Opens the spaceport bar window.
 */
static void bar_open( unsigned int wid )
{
   int w, h;
   int iw, ih;
   int bw, bh;
   int th;

   /* Mark as generated. */
   land_tabGenerate(LAND_WINDOW_BAR);

   /* Set window functions. */
   window_onClose( wid, bar_close );

   /* Get dimensions. */
   bar_getDim( wid, &w, &h, &iw, &ih, &bw, &bh );

   /* Approach when pressing enter */
   window_setAccept( wid, bar_approach );

   /* Buttons */
   window_addButtonKey(wid, -10, 20,
         bw, bh, "btnCloseBar",
         _("&Take Off"), land_buttonTakeoff, SDLK_t);
   window_addButtonKey(wid, -10 - (bw+10), 20,
         bw, bh, "btnApproach",
         _("&Approach"), bar_approach, SDLK_a);

   /* Add portrait text. */
   window_addText(wid, iw + 40, -40,
         w - iw - 60, gl_defFont.h, 1,
         "txtPortrait", &gl_defFont, NULL, NULL);

   /* Add mission description text. */
   th = -40 - 20 - PORTRAIT_HEIGHT - 20 - 20;
   window_addText( wid, iw + 60, th,
         w - iw - 100, h + th - (2*bh+60), 0,
         "txtMission", &gl_smallFont, NULL, NULL );

   /* Generate the mission list. */
   bar_genList( wid );
   /* Set default keyboard focuse to the list */
   window_setFocus( wid , "iarMissions" );
}

/**
 * @brief Generates the mission list for the bar.
 *
 *    @param wid Window to create mission list for.
 */
static int bar_genList( unsigned int wid )
{
   ImageArrayCell *portraits, *p;
   glTexture *bg;
   char *focused;
   int w, h, iw, ih, bw, bh;
   int i, n, pos;

   /* Validity check. */
   if (wid == 0)
      return 0;

   /* Get dimensions. */
   bar_getDim( wid, &w, &h, &iw, &ih, &bw, &bh );

   /* Save focus. */
   focused = window_getFocus( wid );

   /* Destroy widget if already exists. */
   if (widget_exists( wid, "iarMissions" )) {
      /* Store position. */
      pos = toolkit_getImageArrayPos( wid, "iarMissions" );

      window_destroyWidget( wid, "iarMissions" );
   }
   else
      pos = -1;

   /* We sort just in case. */
   npc_sort();

   /* Set up missions. */
   if (mission_portrait == NULL)
      mission_portrait = gl_newImage( PORTRAIT_GFX_PATH"news.webp", 0 );
   n = npc_getArraySize();
   if (n <= 0) {
      n            = 1;
      portraits    = calloc(1, sizeof(ImageArrayCell));
      portraits[0].image = gl_dupTexture(mission_portrait);
      portraits[0].caption = strdup(_("News"));
   }
   else {
      n            = n+1;
      portraits    = calloc(n, sizeof(ImageArrayCell));
      portraits[0].image = gl_dupTexture(mission_portrait);
      portraits[0].caption = strdup(_("News"));
      for (i=0; i<npc_getArraySize(); i++) {
         p = &portraits[i+1];
         bg = npc_getBackground(i);
         p->caption = strdup( npc_getName(i) );
         if (bg!=NULL) {
            p->image = gl_dupTexture( bg );
            p->layers = gl_addTexArray( p->layers, &p->nlayers, gl_dupTexture( npc_getTexture(i) ) );
         }
         else
            p->image = gl_dupTexture(npc_getTexture(i));
      }
   }
   window_addImageArray( wid, 20, -40,
         iw, ih, "iarMissions", 128, 96,
         portraits, n, bar_update, bar_approach, bar_approach );

   /* Restore position. */
   toolkit_setImageArrayPos( wid, "iarMissions", pos );

   /* write the outfits stuff */
   bar_update( wid, NULL );

   /* Restore focus. */
   window_setFocus( wid, focused );
   free(focused);

   return 0;
}
/**
 * @brief Regenerates the bar list.
 */
void bar_regen (void)
{
   if (!landed)
      return;
   if (!land_loaded)
      return;
   bar_genList( land_getWid(LAND_WINDOW_BAR) );
}
/**
 * @brief Updates the missions in the spaceport bar.
 *    @param wid Window to update the outfits in.
 *    @param str Unused.
 */
static void bar_update( unsigned int wid, char* str )
{
   (void) str;
   int pos;
   int w, h;
   int iw, ih;
   int bw, bh;

   /* Get dimensions. */
   bar_getDim( wid, &w, &h, &iw, &ih, &bw, &bh );

   /* Get array. */
   pos = toolkit_getImageArrayPos( wid, "iarMissions" );

   /* See if is news. */
   if (pos==0) { /* News selected. */
      /* Destroy news widget if needed. */
      if (widget_exists(wid, "cstNews"))
         window_destroyWidget( wid, "cstNews" );

      /* Destroy portrait. */
      if (widget_exists(wid, "imgPortrait"))
         window_destroyWidget(wid, "imgPortrait");
      if (widget_exists(wid, "imgPortraitBG"))
         window_destroyWidget(wid, "imgPortraitBG");

      /* Disable button. */
      window_disableButton( wid, "btnApproach" );

      /* Clear text. */
      window_modifyText(  wid, "txtPortrait", NULL );
      window_modifyText(  wid, "txtMission",  NULL );

      /* Create news. */
      news_widget(wid, iw + 60, -40,
            w - iw - 100, h - 40 - 20 - bh - 20);
      return;
   }

   /* Shift to ignore news now. */
   pos--;

   /* Destroy news widget if needed. */
   if (widget_exists(wid, "cstNews"))
      window_destroyWidget( wid, "cstNews" );

   /* Create widgets if needed. */
   if (!widget_exists(wid, "imgPortraitBG")) /* Must be first */
      window_addImage( wid, iw + 40 + (w-iw-60-PORTRAIT_WIDTH)/2,
            -40 - gl_defFont.h - 20 - PORTRAIT_HEIGHT,
            0, 0, "imgPortraitBG", NULL, 1 );
   if (!widget_exists(wid, "imgPortrait"))
      window_addImage( wid, iw + 40 + (w-iw-60-PORTRAIT_WIDTH)/2,
            -40 - gl_defFont.h - 20 - PORTRAIT_HEIGHT,
            0, 0, "imgPortrait", NULL, 1 );

   /* Enable button. */
   window_enableButton( wid, "btnApproach" );

   /* Set portrait. */
   window_modifyText(  wid, "txtPortrait", npc_getName( pos ) );
   window_modifyImage( wid, "imgPortrait", npc_getTexture( pos ),
         PORTRAIT_WIDTH, PORTRAIT_HEIGHT );
   window_modifyImage( wid, "imgPortraitBG", npc_getBackground( pos ),
         PORTRAIT_WIDTH, PORTRAIT_HEIGHT );

   /* Set mission description. */
   window_modifyText(  wid, "txtMission", npc_getDesc( pos ));
}
/**
 * @brief Closes the mission computer window.
 *    @param wid Window to close.
 *    @param name Unused.
 */
static void bar_close( unsigned int wid, char *name )
{
   (void) wid;
   (void) name;

   /* Must not be regenerating. */
   if (land_regen) {
      land_regen--;
      return;
   }

   gl_freeTexture(mission_portrait);
   mission_portrait = NULL;
}
/**
 * @brief Approaches guy in mission computer.
 */
static void bar_approach( unsigned int wid, char *str )
{
   (void) str;
   int pos, n;

   /* Get position. */
   pos = toolkit_getImageArrayPos( wid, "iarMissions" );

   /* Should never happen, but in case news is selected */
   if (pos == 0)
      return;

   /* Ignore news. */
   pos--;

   n = npc_getArraySize();
   npc_approach( pos );
   /* This check is necessary if the player quits the game in the middle of an NPC approach. */
   if (land_planet==NULL)
      return;
   bar_genList( wid ); /* Always just in case. */

   /* Focus the news if the number of NPCs has changed. */
   if (n != npc_getArraySize())
      toolkit_setImageArrayPos( wid, "iarMissions", 0 );

   /* Reset markers. */
   mission_sysMark();

   /* Mission forced take off. */
   if (land_takeoff)
      takeoff(0);
}
/**
 * @brief Loads the news.
 *
 * @return 0 on success.
 */
static int news_load (void)
{
   generate_news(land_planet->faction);
   return 0;
}


/**
 * @brief Gets the size of the missions window.
 */
static void misn_getSize(wid_t wid, int *w, int *h, int *dw, int *dh, int *lh,
      int *mw, int *bw)
{
   int margins;
   int temp;

   /* Get window dimensions. */
   window_dimWindow(wid, w, h);

   /* Calculate widget dimensions. */
   /* Description and mission list statically get half of the available
    * width minus margins there would be at 720p. Map gets the rest. */
   margins = 20 + 20 + 20;
   temp = (1280-margins) / 2;
   if (dw != NULL)
      *dw = temp;
   if (mw != NULL)
      *mw = *w - margins - temp;

   /* Text statically gets half of the available height minus margins
    * there would be at 720p. Mission list gets the rest. */
   margins = 40 + 10 + 20;
   temp = (720-margins) / 2;
   if (dh != NULL)
      *dh = temp;
   if (lh != NULL)
      *lh = *h - margins - temp;

   if (bw != NULL)
      *bw = ((mw!=NULL?*mw:*w) - 2*10) / 3;
}


/**
 * @brief Opens the mission computer window.
 */
static void misn_open( unsigned int wid )
{
   int w, h, dw, dh, lh, mw, bw;
   int tw, th;
   int mh;

   /* Mark as generated. */
   land_tabGenerate(LAND_WINDOW_MISSION);

   /* Get window dimensions. */
   misn_getSize(wid, &w, &h, &dw, &dh, &lh, &mw, &bw);

   /* Set window functions. */
   window_onClose( wid, misn_close );

   /* buttons */
   window_addButtonKey(wid, -20, 20,
         bw, LAND_BUTTON_HEIGHT, "btnCloseMission",
         _("&Take Off"), land_buttonTakeoff, SDLK_t);
   window_addButtonKey(wid, -20 - 1*(bw+10), 20,
         bw, LAND_BUTTON_HEIGHT, "btnCurrentMissions",
         _("&Current Missions"), misn_currentList, SDLK_c);
   window_addButtonKey(wid, -20 - 2*(bw+10), 20,
         bw, LAND_BUTTON_HEIGHT, "btnAcceptMission",
         _("&Accept Mission"), misn_accept, SDLK_a);

   /* Date text */
   th = gl_printHeightRaw(&gl_defFont, mw,
         _("#nDate:#0 N/A\n"
            "#nFree Space:#0 N/A\n"
            "#nMoney:#0 N/A"));
   window_addText(wid, -20, -40, mw, th, 0,
         "txtDate", NULL, NULL, NULL);

   /* Map */
   mh = h - 40 - th - 10 - (20+LAND_BUTTON_HEIGHT+10);
   map_show(wid, -20, 20 + LAND_BUTTON_HEIGHT + 10, mw, mh, 0.75);

   /* Minimal mode checkbox */
   tw = gl_printWidthRaw(&gl_smallFont, _("Minimal Mode")) + 20;
   window_addCheckbox(wid, -20, 20 + LAND_BUTTON_HEIGHT + 10 + mh + 10,
         tw, 20, "chkMinimal", _("Minimal Mode"),
         misn_chkMinimal, mission_map_minimal);

   /* Description text */
   window_addText(wid, 20, -40 - lh - 10,
         dw, dh, 0, "txtDesc", &gl_defFont, NULL, _("#nReward:#0 None"));

   misn_genList(wid, 1);

   /* Set default keyboard focus to the list */
   window_setFocus( wid , "lstMission" );
}
/**
 * @brief Closes the mission computer window.
 *    @param wid Window to close.
 *    @param name Unused.
 */
static void misn_close( unsigned int wid, char *name )
{
   (void) wid;
   (void) name;
}
/**
 * @brief Accepts the selected mission.
 *    @param wid Window of the mission computer.
 *    @param str Unused.
 */
static void misn_accept( unsigned int wid, char* str )
{
   (void) str;
   char* misn_name;
   Mission* misn;
   int pos;
   int offset;
   int i, ret;

   misn_name = toolkit_getList( wid, "lstMission" );

   /* Make sure you have missions. */
   if (strcmp(misn_name,_("No Missions"))==0)
      return;

   /* Make sure player can accept the mission. */
   for (i=0; i<MISSION_MAX; i++)
      if (player_missions[i]->data == NULL) break;
   if (i >= MISSION_MAX) {
      dialogue_alert( _("You have too many active missions.") );
      return;
   }

   if (dialogue_YesNo( _("Accept Mission"),
         _("Are you sure you want to accept this mission?"))) {
      pos = toolkit_getListPos(wid, "lstMission");
      offset = toolkit_getListOffset(wid, "lstMission");
      misn = &mission_computer[pos];
      ret = mission_accept( misn );
      if ((ret==0) || (ret==3) || (ret==2) || (ret==-1)) { /* success in accepting the mission */
         if (ret==-1)
            mission_cleanup( &mission_computer[pos] );
         memmove( &mission_computer[pos], &mission_computer[pos+1],
               sizeof(Mission) * (mission_ncomputer-pos-1) );
         mission_ncomputer--;

         /* Pretend we're updating tabs. This will prevent map
          * centering from occurring as we mess with the list. */
         updating_tabs = 1;

         /* Regenerate list. */
         misn_genList(wid, 0);

         /* Add position persistancey after a mission has been accepted */
         /* NOTE: toolkit_setListPos protects us from a bad position by clamping */
         toolkit_setListOffset(wid, "lstMission", offset);
         toolkit_setListPos(wid, "lstMission", pos);

         /* Turn off our pretend tabs update. */
         updating_tabs = 0;

         /* Simulate a map click (this regenerates the list again and
          * tries to select a mission in the currently selected
          * system). */
         land_mapTargetSystem();
      }

      /* Reset markers. */
      mission_sysMark();
   }
}
/**
 * @brief Opens the Ship Computer's missions list.
 *    @param wid Window of the mission computer.
 *    @param str Unused.
 */
static void misn_currentList(unsigned int wid, char* str)
{
   (void) wid;
   (void) str;

   menu_info(INFO_MISSIONS);
}
/**
 * @brief Generates the mission list.
 *    @param wid Window to generate the mission list for.
 *    @param first Is it the first time generated?
 */
static void misn_genList( unsigned int wid, int first )
{
   int i, j;
   char **misn_names;
   char *focused;
   int m;
   int w, h, lw, lh;
   int hilight;
   const StarSystem *selected_sys;
   Mission *misn;
   int list_pos;
   int list_offset;
   int first_hilight;
   int prev_pos;

   /* Save focus. */
   focused = window_getFocus(wid);
   list_pos = 0;
   list_offset = 0;

   if (!first) {
      list_pos = toolkit_getListPos(wid, "lstMission");
      list_offset = toolkit_getListOffset(wid, "lstMission");
      window_destroyWidget(wid, "lstMission");
   }

   prev_pos = list_pos;

   /* Get window dimensions. */
   misn_getSize(wid, &w, &h, &lw, NULL, &lh, NULL, NULL);

   /* Clear computer markers. */
   space_clearComputerMarkers();

   /* list */
   m = mission_ncomputer;
   misn_names = NULL;
   first_hilight = -1;
   if (mission_ncomputer > 0) { /* there are missions */
      selected_sys = map_getSelected();
      misn_names = malloc(sizeof(char*) * mission_ncomputer);
      for (i=0; i<mission_ncomputer; i++) {
         misn = &mission_computer[i];

         if (selected_sys != NULL) {
            hilight = 0;
            for (j=0; j<array_size(misn->markers); j++) {
               if (misn->markers[j].sys == selected_sys->id) {
                  hilight = 1;
                  break;
               }
            }
         }
         else {
            hilight = 1;
         }

         if (hilight && (first || map_clicked)) {
            /* Store the first hilighted index so we can wraparound. */
            if (first_hilight < 0)
               first_hilight = i;

            /* Select this mission if it's the next one. */
            if ((list_pos == prev_pos) && (i > list_pos))
               list_pos = i;
         }

         if (misn->title != NULL) {
            asprintf(&misn_names[i], "#%c%s#0",
                  hilight ? 'w' : 'n', misn->title);
         }
         else {
            /* This will generally happen briefly due to mission
             * activity at the accept step, which then leads to a
             * call to land_updateTabs(). That's ok, though, because in
             * that case this function will get called again. In the
             * worst-case, setting the corresponding name entry to
             * "NULL" ensures that the problem is diagnosable. */
            misn_names[i] = strdup("NULL");
         }

         /* Add markers. */
         mission_sysComputerMark(misn);
      }
   }

   /* If selected mission hasn't changed, select the first hilighted
    * mission. */
   if ((first_hilight >= 0) && (list_pos == prev_pos))
      list_pos = first_hilight;

   if ((misn_names == NULL) || (mission_ncomputer == 0)) {
      /* no missions. */
      free(misn_names);
      misn_names = malloc(sizeof(char*));
      misn_names[0] = strdup(_("No Missions"));
      m = 1;
   }

   window_addList(wid, 20, -40, lw, lh,
         "lstMission", misn_names, m, 0, misn_update, NULL);

   /* Restore focus. */
   window_setFocus(wid, focused);
   free(focused);
   toolkit_setListOffset(wid, "lstMission", list_offset);
   toolkit_setListPos(wid, "lstMission", list_pos);
}


/**
 * @brief Handles changes to the minimal mode checkbox.
 *
 *    @param wid Window sending events.
 *    @param str Name of the checkbox causing the event.
 */
static void misn_chkMinimal(unsigned int wid, char* str)
{
   mission_map_minimal = window_checkboxState(wid, str);
   map_setMinimal(mission_map_minimal);
}


/**
 * @brief Updates the mission list.
 *    @param wid Window of the mission computer.
 *    @param str Unused.
 */
static void misn_update( unsigned int wid, char* str )
{
   (void) str;
   char *active_misn;
   Mission* misn;
   char buf[STRMAX];
   size_t l;
   char *time_str;
   char tons[STRMAX_SHORT];
   char cred[STRMAX_SHORT];
   int minimal;

   /* Update date stuff. */
   time_str = ntime_pretty(0, 2);
   tonnes2str(tons, sizeof(tons), player.p->cargo_free);
   credits2str(cred, sizeof(cred), player.p->credits, 2);
   snprintf(buf, sizeof(buf),
         _("#nDate:#0 %s\n"
            "#nFree Space:#0 %s\n"
            "#nMoney:#0 %s"),
         time_str, tons, cred);
   free(time_str);
   window_modifyText(wid, "txtDate", buf);

   active_misn = toolkit_getList( wid, "lstMission" );
   if (strcmp(active_misn,_("No Missions"))==0) {
      window_modifyText(wid, "txtDesc", _("#nReward:#0 None"));
      window_disableButton(wid, "btnAcceptMission");
      return;
   }

   /* Clear computer marker hilights. */
   space_clearComputerMarkerHilights();

   misn = &mission_computer[toolkit_getListPos(wid, "lstMission")];
   mission_sysComputerHilight(misn);
   l = scnprintf(buf, sizeof(buf), _("#nReward:#0 %s"), misn->reward);
   l += scnprintf(&buf[l], sizeof(buf) - l, "\n\n%s", misn->desc);
   window_modifyText(wid, "txtDesc", buf);
   window_enableButton( wid, "btnAcceptMission" );

   /* Make sure the map is in the proper mode. */
   map_setMode(MAPMODE_TRAVEL);
   minimal = window_checkboxState(wid, "chkMinimal");
   map_setMinimal(minimal);

   /* Center map on the selected mission unless the map is being clicked
    * or this was called by land_updateTabs(). (These conditions prevent
    * the map from being moved all over the place as necessary land
    * window updates happen while still allowing clicking on the list to
    * center the clicked mission.) */
   if ((misn->markers != NULL) && !updating_tabs && !map_clicked)
      map_center(system_getIndex(misn->markers[0].sys)->name);
}


/**
 * @brief Refuels the player's current ship, if possible.
 */
void land_refuel (void)
{
   unsigned int w;

   /* Full fuel. */
   if (player.p->fuel >= player.p->fuel_max)
      return;

   /* No refuel service. */
   if (!planet_hasService(land_planet, PLANET_SERVICE_REFUEL))
      return;

   player.p->fuel = player.p->fuel_max;

   w = land_getWid( LAND_WINDOW_EQUIPMENT );
   if (w > 0)
      equipment_updateShips( w, NULL ); /* Must update counter. */
}


/**
 * @brief Saves a snapshot.
 */
static void spaceport_saveSnapshot(unsigned int wid, char *str)
{
   (void) wid;
   (void) str;
   char *annotation;

   /* Do not attempt to save if saving is off. */
   if (player_isFlag(PLAYER_NOSAVE)) {
      dialogue_msgRaw(_("Save Snapshot"),
            _("Cannot save; saving is currently being restricted by a mission"
               " or event."));
      return;
   }

   annotation = dialogue_input(_("Save Snapshot"), 1, 60,
         _("Please enter a name for the snapshot:"));

   if (annotation != NULL)
      save_snapshot(annotation);

   free(annotation);
}


/**
 * @brief Updates info on the main tab.
 */
static void land_updateMainTab(void)
{
   char buf[STRMAX];
   char cred[STRMAX_SHORT];
   char tons[STRMAX_SHORT];
   char pop[STRMAX_SHORT];
   char *time_str;
   Outfit *o;
   long double p = land_planet->population;
   char scratch[STRMAX_SHORT];
   const char *digits[] = {
      "\xe2\x81\xb0", "\xc2\xb9", "\xc2\xb2", "\xc2\xb3", "\xe2\x81\xb4",
      "\xe2\x81\xb5", "\xe2\x81\xb6", "\xe2\x81\xb7", "\xe2\x81\xb8",
      "\xe2\x81\xb9"};
   int state = 0, COEF = 0, E = 1, EXP = 4;
   size_t l = 0;

   /* Handle the Save Snapshot button. */
   window_enableButton(land_getWid(LAND_WINDOW_MAIN), "btnSaveSnapshot");
   if (player_isFlag(PLAYER_NOSAVE))
      window_disableButton(land_getWid(LAND_WINDOW_MAIN), "btnSaveSnapshot");

   if (p < 1.0e3)
      snprintf(pop, sizeof(pop), "%.0Lf", p);
   else {
      snprintf(scratch, sizeof(scratch), "%.1Le", p);
      for (const char *c = scratch; *c; c++) {
         if (state == COEF && *c != 'e')
            l += scnprintf(&pop[l], sizeof(pop)-l, "%c", *c);
         else if (state == COEF ) {
            l += scnprintf(&pop[l], sizeof(pop)-l, "%s", "\xc3\x97" "10");
            state = E;
         }
         else if (state == E && (*c == '+' || *c == '0'))
            state = E;
         else {
            state = EXP;
            l += scnprintf(&pop[l], sizeof(pop)-l, "%s", digits[*c-'0']);
         }
      }
   }

   /* Update credits. */
   time_str = ntime_pretty(0, 2);
   tonnes2str(tons, sizeof(tons), player.p->cargo_free);
   credits2str(cred, sizeof(cred), player.p->credits, 2);
   snprintf(buf, sizeof(buf),
         _("%s (%s)\n"
         "#nClass:#0 %s\n"
         "#nFaction:#0 %s\n"
         "#nPopulation:#0 %s\n"
         "\n"
         "#nDate:#0 %s\n"
         "#nFree Space:#0 %s\n"
         "#nMoney:#0 %s"),
         _(land_planet->name), _(cur_system->name),
         _(land_planet->class),
         faction_isFaction(land_planet->faction) ?
            _(faction_name(land_planet->faction)) : _("None"),
         pop,
         time_str, tons, cred);
   free(time_str);
   window_modifyText(land_getWid(LAND_WINDOW_MAIN), "txtDInfo", buf);

   /* Maps are only offered if the planet provides fuel. */
   if (!planet_hasService(land_planet, PLANET_SERVICE_REFUEL))
      return;

   o = outfit_get( LOCAL_MAP_NAME );
   if (o == NULL) {
      WARN( _("Outfit '%s' does not exist!"), LOCAL_MAP_NAME);
      return;
   }
}


void land_updateTabs(void)
{
   wid_t w;
   int tab;
   int i;

   if (!landed)
      return;

   updating_tabs = 1;

   tab = window_tabWinGetActive(land_wid, "tabLand");

   /* Find the currently selected tab. */
   for (i=0; i<LAND_NUMWINDOWS; i++) {
      if (land_windowsMap[i] == tab) {
         last_window = i;
         w = land_getWid(i);

         /* Ensure the tab being switched to is generated (in case we're
          * doing this during a land hook), and also regenerate lists as
          * needed. */
         switch (i) {
            case LAND_WINDOW_MAIN:
               land_updateMainTab();
               break;
            case LAND_WINDOW_OUTFITS:
               if (!land_tabGenerated(i))
                  outfits_open(w, NULL);
               outfits_update(w, NULL);
               break;
            case LAND_WINDOW_SHIPYARD:
               if (!land_tabGenerated(i))
                  shipyard_open(w);
               shipyard_update(w, NULL);
               break;
            case LAND_WINDOW_BAR:
               if (!land_tabGenerated(i))
                  bar_open(w);
               bar_update(w, NULL);
               break;
            case LAND_WINDOW_MISSION:
               if (!land_tabGenerated(i))
                  misn_open(w);
               misn_genList(w, 0);
               misn_update(w, NULL);
               break;
            case LAND_WINDOW_COMMODITY:
               if (!land_tabGenerated(i))
                  commodity_exchange_open(w);
               commodity_regenList(w);
               commodity_update(w, NULL);
               break;
            case LAND_WINDOW_EQUIPMENT:
               if (!land_tabGenerated(i))
                  equipment_open(w);
               equipment_updateShips(w, NULL);
               equipment_updateOutfits(w, NULL);
               break;

            default:
               break;
         }

         /* Clear markers if not on Mission Computer tab. */
         if (i != LAND_WINDOW_MISSION) {
            space_clearComputerMarkers();
            space_clearComputerMarkerHilights();
         }

         break;
      }
   }

   updating_tabs = 0;
}


void land_mapTargetSystem(void)
{
   map_clicked = 1;
   land_updateTabs();
   map_clicked = 0;
}


/**
 * @brief Wrapper for takeoff mission button.
 *
 *    @param wid Window causing takeoff.
 *    @param unused Unused.
 */
void land_buttonTakeoff( unsigned int wid, char *unused )
{
   (void) wid;
   (void) unused;
   /* We'll want the time delay. */
   takeoff(1);
}


/**
 * @brief Cleans up the land window.
 *
 *    @param wid Window closing.
 *    @param name Unused.
 */
static void land_cleanupWindow( unsigned int wid, char *name )
{
   (void) wid;
   (void) name;

   /* Must not be regenerating. */
   if (land_regen) {
      land_regen--;
      return;
   }

   /* Remove computer markers just in case. */
   space_clearComputerMarkers();
   space_clearComputerMarkerHilights();

   /* Clean up possible stray graphic. */
   if (gfx_exterior != NULL) {
      gl_freeTexture( gfx_exterior );
      gfx_exterior = NULL;
   }
}


/**
 * @brief Gets the WID of a window by type.
 *
 *    @param window Type of window to get wid (LAND_WINDOW_MAIN, ...).
 *    @return 0 on error, otherwise the wid of the window.
 */
unsigned int land_getWid( int window )
{
   if (land_windowsMap[window] == -1)
      return 0;
   return land_windows[land_windowsMap[window]];
}


/**
 * @brief Recreates the land windows.
 *
 *    @param load Is loading game?
 *    @param changetab Should it change to the last open tab?
 */
void land_genWindows( int load, int changetab )
{
   int i, j;
   const char *names[LAND_NUMWINDOWS];
   int w, h;
   Planet *p;
   int regen;

   /* Destroy old window if exists. */
   if (land_wid > 0) {
      land_regen = 2; /* Mark we're regenning. */
      window_destroy(land_wid);

      /* Mark tabs as not generated. */
      land_generated = 0;
   }
   land_loaded = 0;

   /* Get planet. */
   p     = land_planet;
   regen = landed;

   /* Create window. */
   if (SCREEN_W < LAND_WIDTH || SCREEN_H < LAND_HEIGHT) {
      w = -1; /* Fullscreen. */
      h = -1;
   }
   else {
      w = LAND_WIDTH + 0.5 * (SCREEN_W - LAND_WIDTH);
      h = LAND_HEIGHT + 0.5 * (SCREEN_H - LAND_HEIGHT);
   }
   land_wid = window_create( "wdwLand", _(p->name), -1, -1, w, h );
   window_onClose( land_wid, land_cleanupWindow );

   /* Set window map to invalid. */
   for (i=0; i<LAND_NUMWINDOWS; i++)
      land_windowsMap[i] = -1;

   /* See what is available. */
   j = 0;
   /* Main. */
   land_windowsMap[LAND_WINDOW_MAIN] = j;
   names[j++] = _("Land Info");
   /* Bar. */
   if (planet_hasService(land_planet, PLANET_SERVICE_BAR)) {
      land_windowsMap[LAND_WINDOW_BAR] = j;
      names[j++] = _("Spaceport Bar");
   }
   /* Missions. */
   if (planet_hasService(land_planet, PLANET_SERVICE_MISSIONS)) {
      land_windowsMap[LAND_WINDOW_MISSION] = j;
      names[j++] = _("Mission Computer");
   }
   /* Outfits. */
   if (planet_hasService(land_planet, PLANET_SERVICE_OUTFITS)) {
      land_windowsMap[LAND_WINDOW_OUTFITS] = j;
      names[j++] = _("Outfit Shop");
   }
   /* Shipyard. */
   if (planet_hasService(land_planet, PLANET_SERVICE_SHIPYARD)) {
      land_windowsMap[LAND_WINDOW_SHIPYARD] = j;
      names[j++] = _("Ship Dealer");
   }
   /* Equipment. */
   if (planet_hasService(land_planet, PLANET_SERVICE_OUTFITS) ||
         planet_hasService(land_planet, PLANET_SERVICE_SHIPYARD)) {
      land_windowsMap[LAND_WINDOW_EQUIPMENT] = j;
      names[j++] = _("Hangar");
   }
   /* Commodity. */
   if (planet_hasService(land_planet, PLANET_SERVICE_COMMODITY)) {
      land_windowsMap[LAND_WINDOW_COMMODITY] = j;
      names[j++] = _("Commodity Exchange");
   }

   /* Create tabbed window. */
   land_windows = window_addTabbedWindow( land_wid, -1, -1, -1, -1, "tabLand", j, names, 0 );

   /*
    * Order here is very important:
    *
    *  1) Create main tab - must have decent background.
    *  2) Set landed, play music and run land hooks - so hooks run well.
    *  3) Generate missions - so that campaigns are fluid.
    *  4) Create other tabs - lists depend on NPC and missions.
    */

   /* Create main tab. */
   land_createMainTab(land_getWid(LAND_WINDOW_MAIN));

   /* Update the main tab in case a modal dialog gets opened (to prevent
    * display inconsistencies). */
   land_updateMainTab();

   /* Set as landed. */
   landed = 1;

   /* Run hooks. */
   if (!regen) {
      music_choose("land"); /* Must be before hooks in case hooks change music. */
      /* We don't run the "land" hook when loading. If you want to have it do stuff when loading, use the "load" hook.
       * Note that you can use the same function for both hooks. */
      if (!load)
         hooks_run("land");
      events_trigger( EVENT_TRIGGER_LAND );

      /* Generate computer and bar missions. */
      /* Generate bar missions first for claims. */
      if (planet_hasService(land_planet, PLANET_SERVICE_BAR) && !planet_isFlag(land_planet, PLANET_NOMISNSPAWN))
         npc_generateMissions(); /* Generate bar npc. */
      if (planet_hasService(land_planet, PLANET_SERVICE_MISSIONS))
         mission_computer = missions_genList( &mission_ncomputer,
               land_planet->faction, land_planet->name, cur_system->name,
               MIS_AVAIL_COMPUTER );
   }

   /* Create other tabs. */
#define should_open(s, w) \
   (planet_hasService(land_planet, s) && (!land_tabGenerated(w)))

   /* Things get a bit hairy here. Hooks may have triggered a GUI reload via
    * e.g. player.swapShip, so the land tabs may have been generated already
    * and we need to check that before regenerating them.
    */

   /* Basic - bar + missions */
   if (should_open( PLANET_SERVICE_BAR, LAND_WINDOW_BAR ))
      bar_open( land_getWid(LAND_WINDOW_BAR) );
   if (should_open( PLANET_SERVICE_MISSIONS, LAND_WINDOW_MISSION ))
      misn_open( land_getWid(LAND_WINDOW_MISSION) );
   /* Outfits. */
   if (should_open( PLANET_SERVICE_OUTFITS, LAND_WINDOW_OUTFITS ))
      outfits_open( land_getWid(LAND_WINDOW_OUTFITS), NULL );
   /* Shipyard. */
   if (should_open( PLANET_SERVICE_SHIPYARD, LAND_WINDOW_SHIPYARD ))
      shipyard_open( land_getWid(LAND_WINDOW_SHIPYARD) );
   /* Equipment. */
   if ((planet_hasService(land_planet, PLANET_SERVICE_OUTFITS) ||
         planet_hasService(land_planet, PLANET_SERVICE_SHIPYARD)) &&
         !land_tabGenerated( LAND_WINDOW_EQUIPMENT ))
      equipment_open( land_getWid(LAND_WINDOW_EQUIPMENT) );
   /* Commodity. */
   if (should_open( PLANET_SERVICE_COMMODITY, LAND_WINDOW_COMMODITY ))
      commodity_exchange_open( land_getWid(LAND_WINDOW_COMMODITY) );
#undef should_open

   if (!regen) {
      /* Reset markers if needed. */
      mission_sysMark();

      /* Check land missions. */
      if (!has_visited(VISITED_LAND)) {
         missions_run(MIS_AVAIL_LAND, land_planet->faction,
               land_planet->name, cur_system->name);
         visited(VISITED_LAND);
      }
   }

   /* Go to last open tab. */
   window_tabWinOnChange( land_wid, "tabLand", land_changeTab );
   if (changetab && land_windowsMap[ last_window ] != -1)
      window_tabWinSetActive( land_wid, "tabLand", land_windowsMap[ last_window ] );

   /* Update tabs. */
   land_updateTabs();

   /* Refuel if necessary. */
   land_refuel();

   /* Finished loading. */
   land_loaded = 1;

   /* Necessary if player.land() was run in an abort() function. */
   window_lower( land_wid );
}


/**
 * @brief Sets the land window tab.
 *
 *    @param window Tab to set like LAND_WINDOW_COMMODITY.
 *    @return 0 on success.
 */
int land_setWindow( int window )
{
   if (land_windowsMap[window] < 0)
      return -1;

   window_tabWinSetActive(land_wid, "tabLand", land_windowsMap[window]);
   land_changeTab(land_wid, "tabLand", land_windowsMap[last_window],
         land_windowsMap[window]);
   return 0;
}


/**
 * @brief Opens up all the land dialogue stuff.
 *    @param p Planet to open stuff for.
 *    @param load Whether or not loading the game.
 */
void land( Planet* p, int load )
{
   /* Do not land twice. */
   if (landed)
      return;
   
   /* Clear some unnecessary flags. */
   pilot_rmFlag( player.p, PILOT_COOLDOWN_BRAKE);
   pilot_rmFlag( player.p, PILOT_COOLDOWN );

   /* Resets the player's heat. */
   pilot_heatReset( player.p );

   /* Heal the player so GUI shows player at full everything. */
   pilot_healLanded( player.p );

   /* Stop player sounds. */
   player_soundStop();

   /* Load stuff */
   land_planet = p;
   gfx_exterior = gl_newImage( p->gfx_exterior, 0 );

   /* Generate the news. */
   if (planet_hasService(land_planet, PLANET_SERVICE_BAR))
      news_load();

   /* Clear the NPC. */
   npc_clear();

   /* Create all the windows. */
   land_genWindows( load, 0 );

   /* Hack so that load can run player.takeoff(). */
   if (load)
      hooks_run( "load" );

   /* Just in case? */
   bar_regen();

   /* Mission forced take off. */
   if (land_takeoff)
      takeoff(0);
}


/**
 * @brief Creates the main tab.
 *
 *    @param wid Window to create main tab.
 */
static void land_createMainTab( unsigned int wid )
{
   glTexture *logo;
   int w, h;
   int bw;

   /* Get window dimensions. */
   window_dimWindow( wid, &w, &h );

   /*
    * Faction logo.
    */
   if (faction_isFaction(land_planet->faction)) {
      logo = faction_logoSmall(land_planet->faction);
      if (logo != NULL) {
         window_addImage( wid, 440 + (w-460-logo->w)/2, -20,
               0, 0, "imgFaction", logo, 0 );
      }
   }

   bw = LAND_BUTTON_WIDTH;

   /* Land image. */
   window_addImage(wid, 20, -40, 400, 400, "imgPlanet", gfx_exterior, 1);

   /* Player stats. */
   window_addText(wid, 20, -40 - 400 - 20,
         400, h - 40 - 400 - 20 - 20,
         0, "txtDInfo", &gl_defFont, NULL, NULL);

   /*
    * buttons
    */
   /* first column */
   window_addButton(wid, -10, 20,
         bw, LAND_BUTTON_HEIGHT, "btnTakeoff",
         _("&Take Off"), land_buttonTakeoff);
   window_addButton(wid, -10 - 1*(bw+10), 20,
         bw, LAND_BUTTON_HEIGHT, "btnSaveSnapshot",
         _("&Save Snapshot"), spaceport_saveSnapshot);

   /* Add "no refueling" notice if needed. */
   if (!planet_hasService(land_planet, PLANET_SERVICE_REFUEL)) {
      window_addText(land_getWid(LAND_WINDOW_MAIN),
            -20, 20 + LAND_BUTTON_HEIGHT + 20,
            200, gl_defFont.h, 1, "txtRefuel",
            &gl_defFont, NULL, _("No refueling services."));
   }
}


/**
 * @brief Saves the last place the player was.
 *
 *    @param wid Unused.
 *    @param wgt Unused.
 *    @param old Previously-active tab. (Unused)
 *    @param tab Tab changed to.
 */
static void land_changeTab( unsigned int wid, char *wgt, int old, int tab )
{
   int i;
   const char *torun_hook;
   unsigned int to_visit;
   (void) wid;
   (void) wgt;
   (void) old;

   /* Center the map on the current system and set map zoom for the
    * benefit of tabs that have an embedded map. (Done here since we
    * only want to do this specifically when changing tabs.) */
   map_setZoom(0.75);
   map_center(cur_system->name);

   /* Update tabs. */
   land_updateTabs();

   /* Safe defaults. */
   torun_hook = NULL;
   to_visit = 0;

   /* Find what switched. */
   for (i=0; i<LAND_NUMWINDOWS; i++) {
      if (land_windowsMap[i] == tab) {
         switch (i) {
            case LAND_WINDOW_MAIN:
               break;
            case LAND_WINDOW_OUTFITS:
               to_visit = VISITED_OUTFITS;
               torun_hook = "outfits";
               break;
            case LAND_WINDOW_SHIPYARD:
               to_visit = VISITED_SHIPYARD;
               torun_hook = "shipyard";
               break;
            case LAND_WINDOW_BAR:
               to_visit = VISITED_BAR;
               torun_hook = "bar";
               break;
            case LAND_WINDOW_MISSION:
               to_visit = VISITED_MISSION;
               torun_hook = "mission";
               break;
            case LAND_WINDOW_COMMODITY:
               to_visit = VISITED_COMMODITY;
               torun_hook = "commodity";
               break;
            case LAND_WINDOW_EQUIPMENT:
               to_visit = VISITED_EQUIPMENT;
               torun_hook = "equipment";
               break;

            default:
               break;
         }
         break;
      }
   }

   /* Run hooks, run after music in case hook wants to change music. */
   if (torun_hook != NULL)
      if (hooks_run(torun_hook) > 0)
         bar_genList(land_getWid(LAND_WINDOW_BAR));

   visited(to_visit);

   if (land_takeoff)
      takeoff(1);
}


/**
 * @brief Makes the player take off if landed.
 *
 *    @param delay Whether or not to have time pass as if the player landed normally.
 */
void takeoff( int delay )
{
   int h, seconds;
   char *nt;
   double a, r;

   if (!landed)
      return;

   /* Player's ship is not able to fly. */
   if (!player_canTakeoff()) {
      char message[STRMAX_SHORT];
      pilot_reportSpaceworthy( player.p, message, sizeof(message) );
      dialogue_msgRaw( _("Ship not fit for flight"), message );

      /* Check whether the player needs rescuing. */
      land_stranded();

      return;
   }

   /* Clear queued takeoff. */
   land_takeoff = 0;

   /* Refuel if needed. */
   land_refuel();

   /* Reset last tab so we don't get issues next time we land. */
   last_window = 0;

   /* In case we had paused messy sounds. */
   sound_stopAll();

   /* to randomize the takeoff a bit */
   a = RNGF() * 2. * M_PI;
   r = RNGF() * land_planet->radius;

   /* no longer authorized to land */
   player_rmFlag(PLAYER_LANDACK);
   pilot_rmFlag(player.p,PILOT_LANDING); /* No longer landing. */

   /* set player to another position with random facing direction and no vel */
   player_warp( land_planet->pos.x + r * cos(a), land_planet->pos.y + r * sin(a) );
   vect_pset( &player.p->solid->vel, 0., 0. );
   player.p->solid->dir = RNGF() * 2. * M_PI;
   cam_setTargetPilot( player.p->id, 0 );

   /* heal the player */
   pilot_healLanded( player.p );

   /* Refill ammo */
   pilot_fillAmmo( player.p );

   /* Clear planet target. Allows for easier autonav out of the system. */
   player_targetPlanetSet(-1, 1);

   /* Clear pilots other than player. */
   pilots_clean(0);

   /* initialize the new space */
   h = player.p->nav_hyperspace;
   space_init(NULL);
   player.p->nav_hyperspace = h;

   /* cleanup */
   /* Saving must be before cleaning up planet */
   if (save_all() < 0)
      dialogue_alert( _("Failed to save game! You should exit and check the log to see what happened and then file a bug report!") );

   /* time goes by, triggers hook before takeoff */
   if (delay) {
      /* TODO should this depend on something else? */
      seconds = (int)(NT_DAY_SECONDS * player.p->stats.land_delay);
      ntime_inc(ntime_create(0, 0, seconds));
   }
   nt = ntime_pretty( 0, 2 );
   player_message( _("#oTaking off from %s on %s."), _(land_planet->name), nt);
   free(nt);

   land_cleanup();
   player_addEscorts();

   /* Lua stuff must be run after cleanup and after adding escorts. */
   hooks_run("takeoff");
   if (menu_isOpen(MENU_MAIN))
      return;

   hooks_run("enter");
   if (menu_isOpen(MENU_MAIN))
      return;

   events_trigger(EVENT_TRIGGER_ENTER);
   missions_run(MIS_AVAIL_SPACE, -1, NULL, NULL);
   if (menu_isOpen(MENU_MAIN))
      return;

   player.p->landing_delay = PILOT_TAKEOFF_DELAY * player_dt_default();
   player.p->ptimer = player.p->landing_delay;
   pilot_setFlag( player.p, PILOT_TAKEOFF );
   pilot_setThrust( player.p, 0. );
   pilot_setTurn( player.p, 0. );

   /* Reset speed */
   player_autonavResetSpeed();
}


/**
 * @brief Runs the rescue script if players are stuck.
 */
static void land_stranded (void)
{
   char *buf;
   size_t bufsize;
   const char *file = RESCUE_PATH;

   /* Nothing to do if there's no rescue script. */
   if (!PHYSFS_exists(file))
      return;

   if (rescue_env == LUA_NOREF) {
      rescue_env = nlua_newEnv(1);
      nlua_loadStandard( rescue_env );
      nlua_loadTk( rescue_env );

      buf = ndata_read( file, &bufsize );
      if (nlua_dobufenv(rescue_env, buf, bufsize, file) != 0) {
         WARN( _("Error loading file: %s\n"
             "%s\n"
             "Most likely Lua file has improper syntax, please check"),
               file, lua_tostring(naevL,-1));
         free(buf);
         return;
      }
      free(buf);
   }

   /* Run Lua. */
   nlua_getenv(rescue_env,"rescue");
   if (nlua_pcall(rescue_env, 0, 0)) { /* error has occurred */
      WARN( _("Rescue: 'rescue' : '%s'"), lua_tostring(naevL,-1));
      lua_pop(naevL,1);
   }
}


/**
 * @brief Cleans up some land-related variables.
 */
void land_cleanup (void)
{
   int i;

   /* Clean up default stuff. */
   land_regen     = 0;
   land_planet    = NULL;
   landed         = 0;
   land_visited   = 0;
   land_generated = 0;

   /* Destroy window. */
   if (land_wid > 0)
      window_destroy(land_wid);
   land_wid       = 0;

   /* Clean up possible stray graphic. */
   if (gfx_exterior != NULL)
      gl_freeTexture( gfx_exterior );
   gfx_exterior   = NULL;

   /* Clean up mission computer. */
   for (i=0; i<mission_ncomputer; i++)
      mission_cleanup( &mission_computer[i] );
   free(mission_computer);
   mission_computer  = NULL;
   mission_ncomputer = 0;

   /* Clean up bar missions. */
   npc_clear();

   /* Clean up shipyard. */
   shipyard_cleanup();

   /* Clean up rescue Lua. */
   if (rescue_env != LUA_NOREF) {
      nlua_freeEnv(rescue_env);
      rescue_env = LUA_NOREF;
   }
}


/**
 * @brief Exits all the landing stuff.
 */
void land_exit (void)
{
   land_cleanup();
   equipment_cleanup();
   outfits_cleanup();
}


